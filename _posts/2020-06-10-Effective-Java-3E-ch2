# 객체의 생성과 파괴 

_**객체를 만들어야 할 때와 만들지 말아야 할 때 **_를 구분하는 법, 

_**올바른 객체 생성 방법과 불필요한 생성을 피하는 방법**_, 

_**제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령**_ 을 기술



## [Item1] Consider ```Static Factory Methods```

클라이언트가 인스턴스를 얻는 방법은 ```public 생성자```와 ```static factory method``` 가 있다.

상황에 따라 두방식중 적합한 방식을 이용하자. 

정적 팩토리를 사용하는게 유리한 경우가 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.



### 정적 팩토리 메서드

| <center>장점</center>                                        | <center>단점</center>                                        |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| 이름을 가질 수 있다                                          | 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들수 없다 |
| 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다           | 정적 팩터리 메서드는 프로그래머가 찾기 어렵다                |
| 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다      |                                                              |
| 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다 |                                                              |
| 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다 |                                                              |



## [ITEM2] Consider a ```builder``` when faced with many constructor parameters

정적 팩토리와 생성자에는 선택적 매개변수가 많을때 적절히 대응하기 어렵다는 점이다.



- ### 대안1) 점층적 생성자 패턴

  매개변수를 1부터..전부다 받는 생성자까지 늘려가는 방식. 인스턴스를 만들려면 원하는 매개변수를 모두 포함한 생성자 중 가장 짧은 것을 골라 호출하면 된다.

  _**점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기가 어렵다.**_



- ### 대안2) JavaBeans Pattern

  매개변수가 없는 생성자로 객체를 만든 후, setter메서드를 호출해 원하는 매개변수의 값을 설정하는 방식

  _**객체 하나를 만들려면 메서드를 여러개 호출해야 하고, 객체가 완전히 생성되기 전까지는 ```일관성(consistency)```이 무너진 상태에 놓이게 된다.**_



- ### 대안3) Builder Pattern

  필수 매개변수만으로 생성자(혹은 정적 팩토리)를 호출해 빌더 객체를 얻은 후, 빌더객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수들을 설정한다. 마지막으로 매개변수가 없는 ```build()``` 호출해 필요한 객체를 얻는다.

  ```java
  package effectivejava.chapter2.item2.builder;
  
  // 코드 2-3 빌더 패턴 - 점층적 생성자 패턴과 자바빈즈 패턴의 장점만 취했다. (17~18쪽)
  public class NutritionFacts {
      private final int servingSize;
      private final int servings;
      private final int calories;
      private final int fat;
      private final int sodium;
      private final int carbohydrate;
  
      public static class Builder {
          // 필수 매개변수
          private final int servingSize;
          private final int servings;
  
          // 선택 매개변수 - 기본값으로 초기화한다.
          private int calories      = 0;
          private int fat           = 0;
          private int sodium        = 0;
          private int carbohydrate  = 0;
  
          public Builder(int servingSize, int servings) {
              this.servingSize = servingSize;
              this.servings    = servings;
          }
  
          public Builder calories(int val)
          { calories = val;      return this; }
          public Builder fat(int val)
          { fat = val;           return this; }
          public Builder sodium(int val)
          { sodium = val;        return this; }
          public Builder carbohydrate(int val)
          { carbohydrate = val;  return this; }
  
          public NutritionFacts build() {
              return new NutritionFacts(this);
          }
      }
  
      private NutritionFacts(Builder builder) {
          servingSize  = builder.servingSize;
          servings     = builder.servings;
          calories     = builder.calories;
          fat          = builder.fat;
          sodium       = builder.sodium;
          carbohydrate = builder.carbohydrate;
      }
  
      public static void main(String[] args) {
        	// method chaining
          NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
                  .calories(100).sodium(35).carbohydrate(27).build();
      }
  }
  ```

  빌더 패턴은 ```계층적으로 설계된 클래스```와 함께 쓰기에 좋다. 빌더 하나로 여러 객체를 순회하면서 만들 수 있고, 빌더에 넘기는 매개변수에 따라 다른 객체를 만들 수도 있어 ```유연```하다.

  생성자나 정적 팩토리가 **처리해야 할 매개변수가 많다면** 빌더 패턴을 선택하는게 더 낫다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 ```간결```하고, 자바빈즈보다 훨씬 ```안전```하다.

  빌더 패턴의 단점은 객체를 만들기 위해서는 빌더부터 만들어야 해서 ```빌더 생성비용```이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수 있다. 또 점층적 생성자 패턴보다는 ```코드가 장황```해서 매개변수가 4개이상은 되어야 값어치를 한다.

  API는 시간이 지날수록 매개변수가 많아지는 경향이 있으므로 애초에 빌더로 시작하는 편이 나을 때가 많다.



## [ITEM3] private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴(singleton)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.

그런데 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.



- ### public static final 필드 방식의 싱글턴

  싱글턴으로 객체를 만들기 위해 생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해둔다.

  ```java
  public class Elvis {
  	public static final Elvis INSTANCE = new Elvis();
    private Elvis() {...}
    
    public ovid leaveTheBuilding() {...}
  }
  ```

  

  private 생성자는 public static final 필드인 Elvis.INSTANCE 를 초기화할 때 딱 한번만 호출된다. 

  public 이나 protected 생성자가 없으므로 Elvis 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장된다.



- ### 정적 팩토리 방식의 싱글턴

  정적 팩토리 메서드를 public static 멤버로 제공한다

  ```java
  public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() {...}
    public static Elvis getInstance() { return INSTANCE; }
    
    public void leaveTheBuilding() {...}
  }
  ```



### public 필드 방식 vs 정적 팩토리 방식

**_public 방식의 장점_**

​	해당 클래스가 싱글턴임이 API에 명백히 드러나는점.

​	간결함

**_정적 팩토리 방식의 장점_**

​	API를 변경하지 않아도 싱글턴이 아니게 변경할 수 있다.

​	제네릭 싱글턴 팩토리로 만들수 있다.



- ### 열거 타입 방식의 싱글턴

  ```java
  public enum Elvis {
    INSTANCE;
    
    public void leaveTheBuilding() {...}
  }
  ```

  

  public 필드 방식과 비슷하지만, 더 간결하고 추가 노력 없이 직렬화할 수 있고, 심지어 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아준다.

  **_대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법_**

  

## [ITEM4] 인스턴스화를 막으려거든 private 생성자를 사용하라

Java.lang.Math와 java.util.Arrays 처럼 정적메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있다.

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아니다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들며, 사용자는 이 생성자가 자동 생성된 것인지 구분할 수 없다.

**_private 생성자를 추가하면 클래스의 인스턴스화를 막을수 있다._**

```java
public Class UtilityClass {
  // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
  private UtilityClass() {
    throw new AssertionError();
  }
  ... // 나머지 코드는 생략
}
```

이 방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 상위 클래스의 생성자를 호출하게 되는데, 이를 private 으로 선언했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버린다.



## [ITEM5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.

클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 하는 조건을 만족해야 한다.

이처럼 의존 객체 주입이란 **인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식**이다.

```java
public class SpellChecker {
  private final Lexicon dictionary;
  
  public SpellChecker(Lexicon dictionary){
    this.dictionary = Objects.requireNonNull(dictionary);
  }
  
  public boolean isValid(String word) {...}
  public List<String> suggestions(String typo) {...}
}
```

의존 객체 주입이라 하는 이 기법은 **```클래스의 유연성```**, **```재사용성```**, **```테스트 용이성```**을 개선해준다.

하지만, 의존성이 수 천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 한다. 의존 객체 주입 프레임워크를 사용하면 이런 어질러짐을 해소할 수 있다.



## [ITEM6] 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.

#### [String Literal vs String Object](https://www.baeldung.com/java-string-pool)

```java
String s = new String("bikini");
String s = "bilini"
```

생성자를 사용하여 String 인스턴스를 생성하는것은 실행될 때마다 인스턴스를 새로 만든다.

반면에 literal을 사용할 경우에는 String pool에 존재하는 오브젝트라면 새로 생성하지않는다



생성자 대신 정적 팩토리 매서드를 제공하는 불편 클래스에서는 정적 팩토리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.```Boolean(String)``` 생성자 대신 ```Boolean.valueOf(String)``` 팩토리 메서드를 사용하는 것이 좋다.



## [ITEM7] 다 쓴 객체 참조를 해제하라

자바에 GC(가비지 콜렉터)가 있기 때문에, GC가 다 쓴 객체를 알아서 회수해간다고 해서 메모리 관리에 더 이상 신경쓰지 않아도 된다는 것은 오해다.

GC을 통해 소멸대상이 되는 객체가 되기 위해서는 어떠한 참조변수에서도 가르키지 않아야 한다.

다쓴 객체에 대한 참조를 해제하지 않으면 가비지 컬렉션의 대상이 되지 않아 계속 메모리가 할당 되는 **```메모리 누수 현상```**이 발생한다.



### 메모리 누수현상의 원인

- #### 객체 참조

  가비지 컬렉션 언어에서는 메모리 누수를 찾기가 아주 까다롭다. 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체 (그리고 또 그 객체들이 참조하는 모든 객체...)를 회수해가지 못한다. 그래서 단 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.

  해법은 해당 참조를 다 썻을 때 null 처리 하면 된다. 하지만 모든 객체를 쓰자마자 일일이 null 처리하는 방법은 프로그램을 필요 이상으로 지저분하게 만들 뿐이다. **_객체 참조를 null 처리하는 일은 예외적인 경우여야 한다._**

  Stack 클래스와 같이 **자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의**하며 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리해줘야 한다.

- #### 캐시

  Map과 같은 캐시에 객체참조를 넣어두고 사용이 끝났는데도 초기화를 안시켜주는 경우 메모리 누수가 발생한다.

  엔트리가 살아 있는 캐시가 필요한 상황이라면 **[WeakHashMap](https://baeldung-cn.com/java-weakhashmap)**을 사용해 캐시를 만들자.

- #### listener or callBack

  클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 뭔가 조치해주지 않는다면 콜백은 계쏙 쌓인다. 이럴 때 콜백을 약한 참조(weak reference)로 저장하면 가비지 컬렉터가 즉시 수거해간다.



> #### 정리
>
> 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 
>
> 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 
>
> 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.



## [ITEM8] finalizer 와 cleaner 사용을 피하라



## [ITEM9] try-finally 보다는 try-with-resources를 사용하라



